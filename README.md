# DS_TermProject

## 1. Business Understanding & Goal Setting
- 주요 연구 질문 정의:
  - **Regression**: 1인 가구/노인 가구의 소비 지출 패턴만으로 이들의 소득분위를 어느정도 예측 가능한가?
  - **Classification**: 1인가구/노인가구 중에 특정 소비 행동('배달음식 고액 지출자', '의료 계열 고액 지출자'등등)을 하는 그룹이 인구통계학적 특성과 다른 소비특징을 가지는가?
- 분석 대상 그룹 명확화: '1인 가구 전체' or '노인 가구 전체'로 진행할 예정
- 현재 사용중인 데이터 셋: 'final_dataset.xlsx' (Window와 MAC간의 폰트 호환 문제로 인한 csv 파일이 아닌 xlsx 파일로 진행)

## 2. 데이터 준비 및 전처리
- 데이터 load: 기존의 데이터인 dataset을 보존하기 위해 df_nan에 저장 후 존재하지 않는 결측치를 새롭게 생성
- 결측치를 제거하고 데이터를 저장할 df_full을 새롭게 생성, 결측치 처리 이후의 데이터를 모두 df_full에 저장
  - 기본 데이터 셋이 공공기관으로부터 이미 정제된 데이터이기 때문에 모두 정렬이 되어있는 상태
  - 결측치가 존재하더라도 바로 앞의 행 값으로 처리하기 위해 **ffill**을 사용
  - 소비 지출 항목의 결측치 처리는 smart_fill 함수를 통해 진행
    1. 총합이 존재하고 일부 항목에서 결측치 발생 -> 총 소비 지출 금액 - Nan 값이 아닌 항목의 총 합(음수가 나오는 경우는 0값으로 처리)
    2. 총합이 결측치이고 모든 항목이 채워져있는 경우 -> 항목의 합으로 Nan 값 처리
    3. 총합과 항목 일부가 모두 결측 → 항목은 그룹 평균으로 채우고 총합은 항목합
    4. 총합은 있지만 항목이 전부 NaN → 12개 항목에 균등 분배
  - 가계 지출 금액 결측치 처리 과정: 소비 지출 금액이 존재하는 경우 -> 110%로 보정
  - 소득 구간 코드 처리
    1. 소득구간코드가 존재하고 소득분위코드가 결측 -> 소득 구간별 평균 분위를 통해 결측치 처리
    2. 소득분위코드는 있고 소득구간코드가 결측 -> 소득 분위별 평균 소득 구간을 통해 결측치 처리
    3. 소득구간코드, 소득분위코드가 모두 결측 -> 가구원수를 기반으로 소득구간코드 예측, 전체 중앙값을 통해 소득10분위 코드의 결측치 처리
  - 도시읍면부구분코드 처리 -> 최빈값 사용

## 3. EDA 
- Box plot을 이용한 outlier 확인 -> 전처리 과정으로 옮기는게 좋아보임
- 공통 EDA:
  - 주요 인구통계학적 feature(가구원수, 가구주_만연령, 가구_소득분위코드 등)의 분포 시각화.
  - 모든 소비지출_ 항목들의 분포 시각화 (histogram, boxplot), 로그 변환/정규화 전후 비교
- Regression 분석 목표 (소득 분위 예측)관련 EDA:
  - target -> 가구_소득분위코드, 해당 분포 확인
  - 각 소비지출_ 항목들이 가구_소득분위코드에 따라 어떻게 다른 분포를 보이는지 시각화 (예: 소득 분위별 각 소비 항목 평균 지출액 막대그래프, 소득 분위별 각 소비 항목 지출액 박스플롯).
  - 이를 통해 "소득 1분위는 특정 항목의 소비가 거의 없을 것이다"라는 가설을 데이터로 확인.
- Classification 분석 목표 (특정 소비 행동 예측) 관련 EDA:
   - 타겟 변수(y_classification) 정의 및 생성: 가장 먼저, 분류 모델로 예측하고 싶은 구체적인 소비 행동을 정의하고, 그 기준에 따라 0 또는 1의 값을 갖는 타겟 변수 컬럼을 만듭니다. (예: "1인 가구 중 '소비지출_오락문화' 항목 지출액이 해당 그룹 내 상위 25%에 속하면 1, 아니면 0")
   - 생성된 y_classification의 클래스별 비율(0과 1의 개수) 확인 및 시각화 (클래스 불균형 점검).
   - 다른 피처들(가구주_만연령, 가구_소득분위코드, 기타 소비지출 항목 등)이 이 y_classification 값에 따라 어떤 분포 차이를 보이는지 시각화 및 분석.
   
## 4. Feature Engineering
- 공통 feature 생성/가공:
  - 소비 비율 변수: 각 소비지출_ 항목을 '총 소비지출액'(모든 가계지출_소비지출_ 항목의 합 또는 가계지출_소비지출금액 컬럼 활용)으로 나눈 비율 변수를 생성합니다. 이는 절대 지출액보다 '소비 성향'을 더 잘 반영할 수 있음.
  - 연령대 그룹 변수: 가구주_만연령을 의미 있는 연령대 그룹으로 범주화.
- 범주형 변수 인코딩: 가구주_성별코드, 가구주_학력코드, 가구주_직업코드, 가구_소득분위코드(회귀의 타겟이 아닌 경우), 지역코드(만약 있다면) 등을 원핫인코딩 또는 필요에 따라 다른 인코딩 기법을 적용.
- (분류 목표 시) 타겟 변수 생성: EDA에서 정의한 기준에 따라 y_classification을 확실히 생성.
- 피처 선택: EDA 결과 및 도메인 지식을 바탕으로 각 모델링 목표(회귀, 분류)에 사용할 최종 피처 세트(X_regression, X_classification)를 구성.

## 5. Modeling & Evaluation
- 공통 준비:
  - 각 분석 목표별로 준비된 피처(X)와 타겟(y)을 훈련 세트와 테스트 세트로 분할 (train_test_split, stratify 옵션은 분류 문제에서 타겟 변수 클래스 불균형 시 유용).
  - 숫자형 피처에 대해 피처 스케일링 적용 (StandardScaler 등. 훈련 세트에 fit_transform, 테스트 세트에 transform).
- A. 회귀 분석: 소비 패턴 기반 소득 분위 예측
  - 타겟 변수 (y_regression): 가구_소득분위코드
  - 피처 (X_regression): 주로 소비지출_ 항목들 (원본 값 또는 비율, 로그 변환 값 등), 필요시 일부 인구통계 피처.
  - 사용 모델:
    - 의사결정 트리 회귀 (Decision Tree Regressor): 사용자님의 아이디어 핵심 모델.
    - 다양한 파라미터 활용: max_depth, min_samples_split, min_samples_leaf 등 조절.
  - 평가 방법:
    - R² (결정계수), MAE, RMSE.
    - 교차 검증 (Cross Validation).
    - 의사결정 트리의 경우: 트리 구조 시각화, 피처 중요도 분석을 통해 "어떤 소비 패턴이 어떤 소득 분위로 분기되는가" 규칙 해석. 예측된 소득 분위(실수값)를 반올림하여 실제 분위와 비교하는 정확도/혼동행렬 유사 분석.
- B. 분류 분석: 특정 소비 행동 예측
  - 타겟 변수 (y_classification): 3단계 EDA에서 정의한 특정 소비 행동 여부 (0 또는 1).
  - 피처 (X_classification): 인구통계학적 피처, 경제상태 피처, (타겟 소비 항목을 제외한) 다른 소비지출 항목 또는 비율.
  - 사용 모델:
    - 로지스틱 회귀 (Logistic Regression): (L1/Lasso, L2 규제 포함하여 다양한 파라미터 시도 - penalty, C, solver)
    - 의사결정 트리 분류 (Decision Tree Classifier): (criterion='gini'/'entropy', max_depth 등 파라미터 변경)
    - K-최근접 이웃 분류 (KNN Classifier): (n_neighbors, weights 등 파라미터 변경)
    - 랜덤 포레스트 (Random Forest Classifier) 등
  - 평가 방법:
    - 정확도 (Accuracy), 정밀도 (Precision), 재현율 (Recall), F1 점수, 혼동 행렬 (Confusion Matrix).
    - ROC 곡선 및 AUC 점수.
    - 교차 검증 (Cross Validation).
